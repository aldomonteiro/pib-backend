{"version":3,"sources":["../../../src/api/controllers/socketController.js"],"names":["io","clientsWeb","clientsWhats","setupSocketIo","server","allowedOrigins","origins","origin","callback","indexOf","console","log","on","socket","originID","logger","color","user","hasOwnProperty","id","emitEventWhats","message","messenger","consume","subscribe","msg","msgJSON","JSON","parse","pageID","eventName","data","emitEvent","event","socketID","sockets","connected","emit","error","userID","userId"],"mappings":"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","sourcesContent":["import socketIo from 'socket.io';\nimport logger from 'node-color-log';\n\nimport messenger from '../../messenger';\n\nvar io;\nvar clientsWeb = {};\nvar clientsWhats = {};\n\nexport const setupSocketIo = (server, allowedOrigins) => {\n    io = socketIo(server);\n\n    io.origins((origin, callback) => {\n        if (allowedOrigins.indexOf(origin) > -1)\n            callback(null, true);\n        else {\n            console.log('>>> SOCKETCONTROLLER trying connect from ', origin);\n            return callback('Socket.io: origin not allowed', false);\n        }\n\n    });\n\n    io.on('connection', socket => {\n        socket.on('acknowledgment', originID => {\n            logger.color('green').log('aknowledment: ' + (originID.user || originID));\n            if (originID.hasOwnProperty('origin') && originID.origin === 'whatsapp') {\n                clientsWhats[originID.user] = socket.id;\n                logger.color('green').log('joining from whatsapp: ' + originID.user);\n                emitEventWhats(originID.user, 'notify', { user: originID.user, message: 'sadkasl' })\n            } else {\n                // this identifier is from a pageID\n                clientsWeb[originID] = socket.id;\n                logger.color('green').log('joining from web: ' + originID);\n            }\n        });\n\n        socket.on('disconnect', () => {\n            for (const id in clientsWeb) {\n                if (clientsWeb[id] === socket.id) {\n                    delete clientsWeb[id];\n                    logger.color('red').log('disconnecting from web ' + id);\n                    break;\n                }\n            }\n            for (const id in clientsWhats) {\n                if (clientsWhats[id] === socket.id) {\n                    delete clientsWhats[id];\n                    logger.color('red').log('disconnecting from whatsapp ' + id);\n                    break;\n                }\n            }\n        });\n    });\n\n    messenger.consume('redis')\n        .subscribe(msg => {\n            const msgJSON = JSON.parse(msg);\n            const { pageID, eventName, data } = msgJSON;\n            emitEvent(pageID, eventName, data);\n        });\n\n    // setInterval(() => {\n    //     const pages = ['278383016327989']\n    //     pages.forEach(page => emitEvent(page, 'talk-to-human', { id: page + Math.round(Math.random() * 100), first_name: 'Try ' }))\n\n    // }, 10000);\n\n    // setInterval(() => {\n    //     const pages = ['938611509676235']\n    //     pages.forEach(page => emitEvent(page, 'talk-to-human', { id: page + Math.round(Math.random() * 100), first_name: 'Try ' }))\n\n    // }, 9000);\n\n    // setInterval(() => {\n    //     const pages = ['307519123184673']\n    //     pages.forEach(page => emitEvent(page, 'talk-to-human', { id: page + Math.round(Math.random() * 100), first_name: 'Try ' }))\n\n    // }, 11000);\n\n    // setInterval(() => {\n    //     const pages = ['2174806159435043']\n    //     pages.forEach(page => emitEvent(page, 'talk-to-human', { id: page + Math.round(Math.random() * 100), first_name: 'Try ' }))\n\n    // }, 12000);\n\n}\n\nexport const emitEvent = (pageID, event, data) => {\n    try {\n        // emiting the event to all sockets created by the pageID query.\n        // I am facing some issue that there are a lot of connected sockets\n        // and it seems that some of then doesn't work.\n        // for (const socketID in io.sockets.connected) {\n        //     const socket = io.sockets.connected[socketID];\n        //     if (socket.handshake.query.pageID === pageID) {\n        //         // sending to all clients in pageID room, except sender\n        //         socket.to(pageID).emit(event, data);\n        //         break;\n        //     }\n        // }\n\n        // This line works, but duplicates the messages.\n        // io.in(pageID).emit(event, data);\n\n        // Here I am storing the socketId for each pageID, but, it seems\n        // the connected socket used on connect is not working to emit events\n        // after awhile.\n        const socketID = clientsWeb[pageID];\n        if (socketID) {\n            const socket = io.sockets.connected[socketID];\n            if (socket) {\n                socket.emit(event, data);\n                logger.color('blue').log('emitted for ' + pageID)\n            }\n            else {\n                logger.color('red').log('no socket for ' + pageID)\n            }\n        } else {\n            logger.color('red').log('no socket for ' + pageID)\n        }\n    } catch (error) {\n        console.error(`Error: ${error.message}`);\n    }\n};\n\nexport const emitEventWhats = (userID, event, data) => {\n    try {\n        // Here I am storing the socketId for each pageID, but, it seems\n        // the connected socket used on connect is not working to emit events\n        // after awhile.\n        const socketID = clientsWhats[userID];\n        if (socketID) {\n            const socket = io.sockets.connected[socketID];\n            if (socket) {\n                socket.emit(event, data);\n                logger.color('blue').log('emitted for ' + userID + ' with data:' + data.userId + ' ' + data.message)\n            } else {\n                logger.color('red').log('no socket for ' + userID)\n            }\n        } else {\n            logger.color('red').log('no socket for ' + userID)\n        }\n    } catch (error) {\n        console.error(`Error: ${error.message}`);\n    }\n};\n\n"],"file":"socketController.js"}